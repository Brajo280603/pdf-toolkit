var u=Object.defineProperty;var y=(s,e,r)=>e in s?u(s,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):s[e]=r;var c=(s,e,r)=>y(s,typeof e!="symbol"?e+"":e,r);import{b as d}from"./FiiLKZqd.js";function w(s){const e=()=>{throw new Error(['Invalid parameter "pages".','Must be a string like "1,2,3" or "1-3" or "1to3"',`Was "${s}" instead.`].join(" "))},r=t=>t.includes("-")||t.toLowerCase().includes("to"),o=t=>{const[n,i]=t.split(/-|to/).map(a=>typeof a=="string"?parseInt(a.trim()):a);return Array.from({length:i-n+1},(a,l)=>n+l)};if(typeof s!="string")e();else if(!s.trim().replace(/ /g,"").match(/^(\d+|\d+-\d+|\d+to\d+)(,(\d+|\d+-\d+|\d+to\d+))*$/))e();else{if(s.trim().match(/^\d+$/))return[parseInt(s.trim())];if(s.trim().includes(","))return s.split(",").flatMap(t=>r(t)?o(t):parseInt(t));if(r(s))return o(s)}e()}class h{constructor(){c(this,"_doc");c(this,"_loadOptions",{ignoreEncryption:!0});this.reset()}reset(){this._doc=void 0}async setMetadata(e){await this._ensureDoc(),e.producer&&this._doc.setProducer(e.producer),e.author&&this._doc.setAuthor(e.author),e.title&&this._doc.setTitle(e.title),e.creator&&this._doc.setCreator(e.creator)}async add(e,r){if(await this._ensureDoc(),typeof r>"u"||r===null||r==="all")await this._addPagesFromDocument(e);else if(typeof r=="number")await this._addPagesFromDocument(e,[r]);else if(Array.isArray(r)){const o=r.map(t=>typeof t=="string"?parseInt(t.trim()):t);await this._addPagesFromDocument(e,o)}else if(typeof r=="string"||r instanceof String){const o=w(r);await this._addPagesFromDocument(e,o)}else throw new Error(['Invalid parameter "pages".','Must be a string like "1,2,3" or "1-3" or an Array of numbers.'].join(" "))}async _ensureDoc(){this._doc||(this._doc=await d.create(),this._doc.setProducer("pdf-merger-js"),this._doc.setCreationDate(new Date))}async _saveAsUint8Array(){return await this._ensureDoc(),await this._doc.save()}async _saveAsBase64(){return await this._ensureDoc(),await this._doc.saveAsBase64({dataUri:!0})}async _getInputAsUint8Array(e){if(e instanceof Uint8Array)return e;if(e instanceof ArrayBuffer||Object.prototype.toString.call(e)==="[object ArrayBuffer]")return new Uint8Array(e);if(typeof Blob<"u"&&e instanceof Blob){const t=await e.arrayBuffer();return new Uint8Array(t)}if(e instanceof URL){if(typeof fetch>"u")throw new Error("fetch is not defined. You need to use a polyfill for this to work.");const n=await(await fetch(e)).arrayBuffer();return new Uint8Array(n)}let o=`pdf-input must be of type ${["Uint8Array","ArrayBuffer","File","Blob","URL"].join(", ")}, a valid filename or url!`;throw typeof e=="string"||e instanceof String?o+=` Input was "${e}" wich is not an existing file, nor a valid URL!`:o+=` Input was of type "${typeof e}" instead.`,new Error(o)}async _addPagesFromDocument(e,r=void 0){const o=await this._getInputAsUint8Array(e),t=await d.load(o,this._loadOptions);let n=[];r===void 0?n=t.getPageIndices():n=r.map(a=>a-1),(await this._doc.copyPages(t,n)).forEach(a=>{this._doc.addPage(a)})}}const f=typeof globalThis=="object"?globalThis:typeof window=="object"?window:typeof self=="object"?self:void 0;class m extends h{async _getInputAsUint8Array(e){if(e instanceof f.File)return new Promise((r,o)=>{const t=new f.FileReader;t.onload=function(n){const i=t.result,a=new Uint8Array(i);return r(a)},t.readAsArrayBuffer(e)});if(typeof e=="string"||e instanceof String){try{new URL(e)}catch{throw new Error(`This is not a valid url: ${e}`)}e=new URL(e)}return await super._getInputAsUint8Array(e)}async saveAsBuffer(){return await this._saveAsUint8Array()}async saveAsBlob(){const e=await this._saveAsUint8Array();return new f.Blob([e],{type:"application/pdf"})}async save(e){const r=await this._saveAsBase64(),o=document.createElement("a");o.href=r,o.download=`${e}.pdf`,o.click()}}export{m as P};
